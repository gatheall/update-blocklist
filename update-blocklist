#!/usr/local/bin/perl -wT
#
# ----------------------------------------------------------------------
# hm2mbox
#
# Written by George A. Theall, theall@tifaware.com
#
# Copyright (c) 2004, George A. Theall. All rights reserved.
#
# This module is free software; you can redistribute it and/or modify
# it under the same terms as Perl itself.
#
# $Id$
# ----------------------------------------------------------------------


=head1 NAME

update-blocklist - Updates firewall blocklist.


=head1 SYNOPSIS

  # updates firewall blocklist.
  update-blocklist

  # display commands used to update firewall blocklist without actually
  #   doing so.
  update-blocklist -d

  # updates firewall blocklist using only static rules. NB: this 
  #   causes any dynamic rules to be removed.
  update-blocklist -s

  # updates firewall blocklist but doesn't retrieve a new copy of
  #   the dynamic list.
  update-blocklist -n


=head1 DESCRIPTION

This script updates rules used by an iptables-based firewall to block
inbound traffic.  You can use it to filter incoming traffic based on the
dynamic list of sources maintained by DShield.org as well as a static
list maintained locally.  The dynamic list, by identifying networks
responsible for the highest number of attacks reported to DShield.org,
helps you stay up-to-date with current threats while the static list
allows you to tailor rules to individual machines. 

Each time you run it, C<update-blocklist> empties and then repopulates
the firewall blocklist (a special user-defined chain through which
inbound traffic passes).  If the dynamic list is retrieved and verified
successfully, a copy will be saved for review or re-use.  It will be
re-used in the event the option C<--no-gets> is given or the current
blocklist can not be retrieved or verified. 

Optional behaviour can be selected using one or more variables or
commandline arguments:

    Variable            Commandline         Purpose
    $DEBUG              -d|--debug          Turn on debugging. NB: leaves
                                                blocklist unchanged.
    n/a                 -n|--no-gets        Update the blocklist but don't
                                                retrieve a new copy of
                                                the dynamic list
    n/a                 -s|--static-only    Update blocklist using only
                                                the static list
    $proxy              n/a                 HTTP proxy (if needed)

C<update-blocklist> is written in Perl.  It should work on any Linux
system with Perl 5 and iptables.  In addition, it makes use of GNU
Privacy Guard to verify the contents of the dynamic blocklist so you
will need to have working that as well.  Finally, it requires the
following Perl modules:

    o Carp
    o Getopt::Long
    o LWP::Debug
    o LWP::UserAgent

If your system does not have these modules installed already, visit CPAN
(L<http://search.cpan.org/>).  Note that C<LWP::Debug> and
C<LWP::UserAgent> are not included with the default Perl distribution so
you may need to install them yourself. 


=head1 KNOWN BUGS AND CAVEATS

Currently, I am not aware of any bugs in this script. 


=head1 DIAGNOSTICS

Warnings and errors will be reported to stderr. 

Failure to retrieve the dynamic blocklist or verify its signature will
result in a warning and cause the previously saved version to be used. 


=head1 SEE ALSO

L<iptables(8)>, L<http://www.dshield.org/block_list_info.php>,
L<http://www.tifaware.com/perl/update-blocklist>.


=head1 AUTHOR

George A. Theall, E<lt>theall@tifaware.comE<gt>


=head1 COPYRIGHT AND LICENSE

Copyright (c) 2003, George A. Theall.
All rights reserved.

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 


=head1 HISTORY

01-Oct-2003, v1.00, George A. Theall
    o Initial version.

=cut


############################################################################
# Make sure we have access to the required modules.
require 5;

use strict;
use Carp;
use Getopt::Long;
use LWP::UserAgent;


############################################################################
# Initialize variables.
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Make %ENV safer
$ENV{PATH} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin';
$| = 1;
my $DEBUG = 0;                          # debugging messages / no updates
my $bl_dynamic = '/etc/sysconfig/blocklist.dynamic';
my $bl_dynamic_url = 'http://feeds.dshield.org/block.txt';
my $bl_dynamic_sig_url = 'http://feeds.dshield.org/block.txt.asc';
my $bl_dynamic_sig_uid = 'DShield.org (Block List) <blocklist@dshield.org>';
my $bl_static = '/etc/sysconfig/blocklist.static';
my $ipt_chain = 'BLOCKLIST';            # iptables chain to use
my $ipt_default_target = 'DROP';        # default target to use for blocking
# nb: sample http proxy settings
#     - no proxy.
my $proxy = '';
#     - unauthenticated proxy via proxy1.domain.com.
# my $proxy = 'http://proxy1.domain.com';
#     - authenticated as user 'user' w/ password 'pass' via proxy2.domain.com.
# my $proxy = 'http://user:pass@proxy2.domain.com';
my $scratch = "/tmp/block-$$.txt";      # temp copy of blocklist
my $useragent = 'update-blocklist/1.00';
umask 0022;


############################################################################
# Process commandline arguments.
my %options = (
    'debug'  => \$DEBUG,
);
Getopt::Long::Configure('bundling');
GetOptions(
    \%options,
    "debug|d!",
    "help|?!",
    "no-gets|n|",
    "static-only|s|",
);
if ($options{help}) {
    print STDERR "Usage: $0 [-d|--debug] [-n|--no-gets] [-s|--static-only]\n";
    exit(9);
}


############################################################################
# Retrieve DShield's dynamic blocklist if desired.
unless ($options{'no-gets'} or $options{'static-only'}) {
    if ($DEBUG) {
        print STDERR "debug: retrieving '$bl_dynamic_url' as '$scratch'.\n" if $DEBUG;
        require LWP::Debug; import LWP::Debug qw(+);
    }
    my $ua = LWP::UserAgent->new(
        agent => $useragent,
    );
    if (defined($proxy)) {
        $ua->proxy('http', $proxy);
    }
    my $response = $ua->get(
        $bl_dynamic_url,
        ':content_file' => $scratch,
    );

    if ($response->is_success) {
        # - retrieve signature.
        print STDERR "debug: retrieving '$bl_dynamic_sig_url' as '$scratch.asc'.\n" if $DEBUG;
        $response = $ua->get(
            $bl_dynamic_sig_url,
            ':content_file' => "$scratch.asc",
        );
        if ($response->is_success) {
            # - attempt to verify signature.
            print STDERR "debug: verifying signature.\n" if $DEBUG;
            my $cmd = "gpg $scratch.asc";
            my $uid;
            open(CMD, "$cmd 2>&1 |") or croak "Can't run '$cmd' - $!\n";
            while (<CMD>) {
                chomp;
                print STDERR "debug:   $_\n" if $DEBUG;
                $uid = $1 if (/Good signature from \"(.+)\"$/i);
            }
            close(CMD);
            my $rc = $? >> 8;
            unlink "$scratch.asc";
            if ($rc or !$uid or $uid ne $bl_dynamic_sig_uid) {
                warn "*** dynamic blocklist not updated - can't verify signature on '$bl_dynamic_url' ($rc)! ***\n";
            }
            else {
                # - update dynamic blocklist.
                if ($DEBUG) {
                    print STDERR "debug: using '$scratch' as dynamic blocklist!\n";
                    $bl_dynamic = $scratch;
                }
                else {
                    my $cmd = "cp $scratch $bl_dynamic";
                    system $cmd;
                    my $rc = $? >> 8;
                    croak "'$cmd' failed with rc $rc!\n" if ($rc);
                    unlink $scratch;
                }
            }
        }
        else {
            warn "*** dynamic blocklist not updated - can't retrieve '$bl_dynamic_sig_url' (", $response->status_line, ")! ***\n";
        }
    }
    else {
        warn "*** dynamic blocklist not updated - can't retrieve '$bl_dynamic_url' (", $response->status_line, ")! ***\n";
    }
}


############################################################################
# Determine blocks to apply.
my @cmds;
# - static blocks.
my $line;
print STDERR "debug: reading static blocks from '$bl_static'.\n" if $DEBUG;
open(FILE, $bl_static) or croak "Can't read '$bl_static' - $!\n";
while (<FILE>) {
    chomp;
    ++$line;
    print STDERR "debug:   line $line: '$_'.\n" if ($DEBUG);
    s/#.*$//;                               # nb: strip out any comments.
    next if (/^\s*$/);                      # nb: skip empty lines.

    my $cmd = "iptables -I $ipt_chain ";

    # Parse / untaint data.
    #
    # - a source specification.
    #   nb: this must occur as the first field.
    if (s/^\s*(\!?\s*[\w\.\/]+)\s*//) {
        $cmd .= "-s $1 ";
    }
    else {
        warn "*** no source specification found in line $line; skipped. ***\n";
        next;
    }
    # - a jump target.
    #   nb: this must occur as the second field, if given.
    if (s/^\s*([^\-\s]+)\s*//) {
        $cmd .= "-j $1 ";
    }
    # - anything left on line will be appended to $cmd.
    #
    #   nb: while this untaints the data, it's not really safe so be 
    #       careful who/what you let write to the static blocklist.
    $cmd .= $1 if (/^\s*(\S.*\S)\s*$/);

    # nb: add a jump if there's not one already.
    $cmd .= " -j $ipt_default_target" unless ($cmd =~ /-j /);

    print STDERR "debug:     command is '$cmd'.\n" if ($DEBUG);
    push(@cmds, $cmd);
}
close(FILE);

# - dynamic blocks.
unless ($options{'static-only'}) {
    print STDERR "debug: reading dynamic blocks from '$bl_dynamic'.\n" if $DEBUG;
    $line = 0;
    open(FILE, $bl_dynamic) or croak "Can't read '$bl_dynamic' - $!\n";
    while (<FILE>) {
        chomp;
        ++$line;
        print STDERR "debug:   line $line: '$_'.\n" if ($DEBUG);
        next unless (/^\d+/);
        my $cmd = "iptables -I $ipt_chain ";

        # Parse / untaint data.
        my($start, $end, $subnet, $attacks, $name, $country, $email) = split(/\t/, $_);
        if ($start =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/) {
            $start = $1;
        }
        else {
            croak "'$start' is not a valid network address in line $line!\n";
        }
        if ($subnet =~ /^(\d{1,2})$/) {
            $subnet = $1;
        }
        else {
            croak "'$subnet' is not a valid subnet in line $line!\n";
        }
        $cmd .= "-s $start/$subnet -j $ipt_default_target";

        print STDERR "debug:     command is '$cmd'.\n" if ($DEBUG);
        push(@cmds, $cmd);
    }
    close(FILE);
}


############################################################################
# Update iptables.
#
# nb: swap order of commands.
@cmds = reverse(@cmds);
# nb: append a rule to allow unmatched traffic to pass.
unshift(@cmds, "iptables -I $ipt_chain -j RETURN");
# nb: add a rule at start to clear out / create chain if needed.
unshift(@cmds, "iptables -F $ipt_chain || iptables -N $ipt_chain");

if ($DEBUG) {
    print STDERR "debug: would issue the following commands:\n",
        "debug:   ", join("\ndebug:   ", @cmds), "\n";
    unless ($options{'static-only'}) {
        print STDERR "debug:\n",
            "debug: updated dynamic blocklist available as '$scratch'\n";
    }
}
else {
    foreach my $cmd (@cmds) {
        system $cmd;
        my $rc = $? >> 8;
        croak "'$cmd' failed with rc $rc!\n" if ($rc);
    }
}
