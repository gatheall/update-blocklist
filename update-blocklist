#!/usr/bin/perl -wT
#
# ----------------------------------------------------------------------
# update-blocklist
#
# Written by George A. Theall, theall@tifaware.com
#
# Copyright (c) 2003-2004, George A. Theall. All rights reserved.
#
# This module is free software; you can redistribute it and/or modify
# it under the same terms as Perl itself.
#
# $Id$
# ----------------------------------------------------------------------


=head1 NAME

update-blocklist - Updates firewall blocklist.


=head1 SYNOPSIS

  # updates firewall blocklist.
  update-blocklist

  # displays commands used to update firewall blocklist without actually
  #   doing so.
  update-blocklist -d

  # updates firewall blocklist using only static rules. NB: this 
  #   causes any dynamic rules to be removed.
  update-blocklist -s

  # updates firewall blocklist but doesn't retrieve a new copy of
  #   the dynamic list.
  update-blocklist -n


=head1 DESCRIPTION

This script updates rules used by an iptables-based firewall to block
inbound traffic.  You can use it to filter incoming traffic based on the
dynamic list of sources maintained by DShield.org as well as a static
list maintained locally.  The dynamic list, by identifying networks
responsible for the highest number of attacks reported to DShield.org,
helps you stay up-to-date with current threats while the static list
allows you to tailor rules to individual machines. 

Each time you run it, B<update-blocklist> empties and then repopulates
the firewall blocklist (a special user-defined chain through which
inbound traffic passes).  If the dynamic list is retrieved and verified
successfully, a copy will be saved for review or re-use.  It will be
re-used in the event the option C<--no-gets> is given or the current
blocklist can not be retrieved or verified. 

Optional behaviour can be selected using one or more variables or
commandline arguments:

    Variable            Commandline         Purpose
    $DEBUG              -d|--debug          Turn on debugging. NB: leaves
                                                blocklist unchanged.
    n/a                 -n|--no-gets        Update the blocklist but don't
                                                retrieve a new copy of
                                                the dynamic list.
    n/a                 -s|--static-only    Update the blocklist using only
                                                the static list.
    $proxy              n/a                 HTTP proxy (if needed).

B<update-blocklist> is written in Perl.  It should work on any Linux
system with Perl 5 and iptables.  In addition, it makes use of GNU
Privacy Guard to verify the contents of the dynamic blocklist so you
will need to have working that as well.  Finally, it requires the
following Perl modules:

    o Carp
    o Getopt::Long
    o LWP::Debug
    o LWP::UserAgent

If your system does not have these modules installed already, visit CPAN
(L<http://search.cpan.org/>).  Note that C<LWP::Debug> and
C<LWP::UserAgent> are not included with the default Perl distribution so
you may need to install them yourself. 


=head1 KNOWN BUGS AND CAVEATS

Currently, I am not aware of any bugs in this script.

If you are having trouble verifying the signature on the dynamic
blocklist, check whether the key used by DShield.org to sign the
blocklist has changed and make sure it agrees with
C<$bl_dynamic_sig_uid>. 

If you encounter a problem using this script, I encourage you to enable
debug mode (eg, add C<-d> to your commandline) and examine the output it
produces before contacting me.  Often, this will enable you to resolve
the problem yourself.


=head1 DIAGNOSTICS

Warnings and errors will be reported to stderr. 

Failure to retrieve the dynamic blocklist or verify its signature will
result in a warning and cause the previously saved version to be used. 


=head1 SEE ALSO

L<iptables(8)>, L<http://www.dshield.org/block_list_info.php>,
L<http://www.tifaware.com/perl/update-blocklist>.

=cut


############################################################################
# Make sure we have access to the required modules.
use 5;
use strict;
use Carp;
use Getopt::Long;
use LWP::UserAgent;


############################################################################
# Initialize variables.
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Make %ENV safer
$ENV{PATH} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin';
$| = 1;
my $DEBUG = 0;                          # debugging messages / no updates
my $bl_dynamic = '/etc/sysconfig/blocklist.dynamic';
my $bl_dynamic_url = 'http://feeds.dshield.org/block.txt';
my $bl_dynamic_sig_url = 'http://feeds.dshield.org/block.txt.asc';
my $bl_dynamic_sig_uid = 'DShield Blocklist (Used to Sign DShield Blocklist) <blocklist@dshield.org>';
my $bl_static = '/etc/sysconfig/blocklist.static';
my $ipt_chain = 'BLOCKLIST';            # iptables chain to use
my $ipt_default_target = 'DROP';        # default target to use for blocking
# nb: sample http proxy settings
#     - no proxy.
my $proxy = '';
#     - unauthenticated proxy via proxy1.domain.com.
# my $proxy = 'http://proxy1.domain.com';
#     - authenticated as user 'user' w/ password 'pass' via proxy2.domain.com.
# my $proxy = 'http://user:pass@proxy2.domain.com';
my $scratch = "/tmp/block-$$.txt";      # temp copy of blocklist
my $useragent = 'update-blocklist/1.0.1' .
                    ' (http://www.tifaware.com/perl/update-blocklist/)';

umask 0022;


############################################################################
# Process commandline arguments.
my %options = (
    'debug'  => \$DEBUG,
);
Getopt::Long::Configure('bundling');
GetOptions(
    \%options,
    "debug|d!",
    "help|h|?!",
    "no-gets|n|",
    "static-only|s|",
) or $options{help} = 1;
$0 =~ s/^.+\///;
if ($options{help}) {
    warn "\n",
        "Usage: $0 [options]\n",
        "\n",
        "Options:\n",
        "  -?, -h, --help             Display this help and exit.\n",
        "  -d, --debug                Display copious debugging messages but\n",
        "                               don't actually change the blocklist.\n",
        "  -n, --no-gets              Update the blocklist but don't retrieve\n",
        "                               a new copy of the dynamic blocklist.\n",
        "  -s, --static-only          Update the blocklist using only the\n",
        "                               static list.\n";
    exit(9);
}


############################################################################
# Retrieve DShield's dynamic blocklist if desired.
unless ($options{'no-gets'} or $options{'static-only'}) {
    if ($DEBUG) {
        warn "debug: retrieving '$bl_dynamic_url' as '$scratch'.\n" if $DEBUG;
        require LWP::Debug; import LWP::Debug qw(+);
    }
    my $ua = LWP::UserAgent->new(
        agent => $useragent,
    );
    if (defined($proxy)) {
        $ua->proxy('http', $proxy);
    }
    my $response = $ua->get(
        $bl_dynamic_url,
        ':content_file' => $scratch,
    );

    if ($response->is_success) {
        # - retrieve signature.
        warn "debug: retrieving '$bl_dynamic_sig_url' as '$scratch.asc'.\n" if $DEBUG;
        $response = $ua->get(
            $bl_dynamic_sig_url,
            ':content_file' => "$scratch.asc",
        );
        if ($response->is_success) {
            # - attempt to verify signature.
            warn "debug: verifying signature.\n" if $DEBUG;
            my $cmd = "gpg $scratch.asc";
            my $uid;
            open(CMD, "$cmd 2>&1 |") or croak "Can't run '$cmd' - $!\n";
            while (<CMD>) {
                chomp;
                warn "debug:   $_\n" if $DEBUG;
                $uid = $1 if (/Good signature from \"(.+)\"$/i);
            }
            close(CMD);
            my $rc = $? >> 8;
            unlink "$scratch.asc";
            if ($rc or !$uid or $uid ne $bl_dynamic_sig_uid) {
                warn "*** dynamic blocklist not updated - can't verify signature on '$bl_dynamic_url' ($rc)! ***\n";
            }
            else {
                # - update dynamic blocklist.
                if ($DEBUG) {
                    warn "debug: using '$scratch' as dynamic blocklist!\n";
                    $bl_dynamic = $scratch;
                }
                else {
                    my $cmd = "cp $scratch $bl_dynamic";
                    system $cmd;
                    my $rc = $? >> 8;
                    croak "'$cmd' failed with rc $rc!\n" if ($rc);
                    unlink $scratch;
                }
            }
        }
        else {
            warn "*** dynamic blocklist not updated - can't retrieve '$bl_dynamic_sig_url' (", $response->status_line, ")! ***\n";
        }
    }
    else {
        warn "*** dynamic blocklist not updated - can't retrieve '$bl_dynamic_url' (", $response->status_line, ")! ***\n";
    }
}


############################################################################
# Determine blocks to apply.
my @cmds;
# - static blocks.
my $line;
warn "debug: reading static blocks from '$bl_static'.\n" if $DEBUG;
open(FILE, $bl_static) or croak "Can't read '$bl_static' - $!\n";
while (<FILE>) {
    chomp;
    ++$line;
    warn "debug:   line $line: '$_'.\n" if ($DEBUG);
    s/#.*$//;                               # nb: strip out any comments.
    next if (/^\s*$/);                      # nb: skip empty lines.

    my $cmd = "iptables -I $ipt_chain ";

    # Parse / untaint data.
    #
    # - a source specification.
    #   nb: this must occur as the first field.
    if (s/^\s*(\!?\s*[\w\.\/]+)\s*//) {
        $cmd .= "-s $1 ";
    }
    else {
        warn "*** no source specification found in line $line; skipped. ***\n";
        next;
    }
    # - a jump target.
    #   nb: this must occur as the second field, if given.
    if (s/^\s*([^\-\s]+)\s*//) {
        $cmd .= "-j $1 ";
    }
    # - anything left on line will be appended to $cmd.
    #
    #   nb: while this untaints the data, it's not really safe so be 
    #       careful who/what you let write to the static blocklist.
    $cmd .= $1 if (/^\s*(\S.*\S)\s*$/);

    # nb: add a jump if there's not one already.
    $cmd .= " -j $ipt_default_target" unless ($cmd =~ /-j /);

    warn "debug:     command is '$cmd'.\n" if ($DEBUG);
    push(@cmds, $cmd);
}
close(FILE);

# - dynamic blocks.
unless ($options{'static-only'}) {
    warn "debug: reading dynamic blocks from '$bl_dynamic'.\n" if $DEBUG;
    $line = 0;
    open(FILE, $bl_dynamic) or croak "Can't read '$bl_dynamic' - $!\n";
    while (<FILE>) {
        chomp;
        ++$line;
        warn "debug:   line $line: '$_'.\n" if ($DEBUG);
        next unless (/^\d+/);
        my $cmd = "iptables -I $ipt_chain ";

        # Parse / untaint data.
        my($start, $end, $subnet, $attacks, $name, $country, $email) = split(/\t/, $_);
        if ($start =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/) {
            $start = $1;
        }
        else {
            croak "'$start' is not a valid network address in line $line!\n";
        }
        if ($subnet =~ /^(\d{1,2})$/) {
            $subnet = $1;
        }
        else {
            croak "'$subnet' is not a valid subnet in line $line!\n";
        }
        $cmd .= "-s $start/$subnet -j $ipt_default_target";

        warn "debug:     command is '$cmd'.\n" if ($DEBUG);
        push(@cmds, $cmd);
    }
    close(FILE);
}


############################################################################
# Update iptables.
#
# nb: swap order of commands.
@cmds = reverse(@cmds);
# nb: append a rule to allow unmatched traffic to pass.
unshift(@cmds, "iptables -I $ipt_chain -j RETURN");
# nb: add a rule at start to clear out / create chain if needed.
unshift(@cmds, "iptables -F $ipt_chain || iptables -N $ipt_chain");

if ($DEBUG) {
    warn "debug: would issue the following commands:\n",
        "debug:   ", join("\ndebug:   ", @cmds), "\n";
    unless ($options{'static-only'}) {
        warn "debug:\n",
            "debug: updated dynamic blocklist available as '$scratch'\n";
    }
}
else {
    foreach my $cmd (@cmds) {
        system $cmd;
        my $rc = $? >> 8;
        croak "'$cmd' failed with rc $rc!\n" if ($rc);
    }
}
